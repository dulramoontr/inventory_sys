const ss = SpreadsheetApp.getActiveSpreadsheet();
const configSheet = ss.getSheetByName('Config');
const itemsSheet = ss.getSheetByName('Items');
const inventoryLogSheet = ss.getSheetByName('InventoryLog');
const CACHE_EXPIRATION = 300; // 快取有效時間 (秒)，這裡設為 5 分鐘
const CACHE_EXPIRATION_LONG = 21600; // 長時間快取 (6小時) for historical data

const BIZ_SHEET_ID = '1zJ78H9uyZ8JcI5SK7FbUzeI-exruWKrYwd2zw3AG6tE';


// --- 快取處理函數 ---
function getDataWithCache(sheet, cacheKey) {
  const cache = CacheService.getScriptCache();
  const cachedData = cache.get(cacheKey);
  if (cachedData) {
    return JSON.parse(cachedData);
  }
  
  const data = sheet.getDataRange().getValues();
  cache.put(cacheKey, JSON.stringify(data), CACHE_EXPIRATION);
  return data;
}

function invalidateCache(cacheKey) {
  const cache = CacheService.getScriptCache();
  cache.remove(cacheKey);
}


// --- API 端點 (doGet, doPost) ---
function doGet(e) {
  const action = e.parameter.action;
  let result;
  try {
    switch (action) {
      case 'getApiEndpoint':
        const apiUrl = PropertiesService.getScriptProperties().getProperty('MAIN_API_URL');
        result = { success: true, url: apiUrl };
        break;
      case 'getItems':
        result = getItems();
        break;
      case 'getInventoryLogs':
        result = getInventoryLogs();
        break;
      case 'getLogById':
        result = getLogById(e.parameter.logId);
        break;
      case 'getDashboardData':
        result = getDashboardData();
        break;
      case 'getHistoricalDashboardData':
        result = getHistoricalDashboardData(e.parameter.startDate, e.parameter.endDate);
        break;
      default:
        result = { success: false, message: 'Invalid action' };
    }
  } catch (error) {
    result = { success: false, message: error.toString() };
  }
  
  return ContentService
    .createTextOutput(JSON.stringify(result))
    .setMimeType(ContentService.MimeType.JSON);
}

function doPost(e) {
  let result;
  try {
    const requestData = JSON.parse(e.postData.contents);
    const action = requestData.action;

    switch (action) {
      case 'verifyAccessCode':
        result = verifyAccessCode(requestData.code);
        break;
      case 'updateSettings':
        result = updateSettings(requestData.payload);
        break;
      case 'saveInventory':
        result = saveInventory(requestData.payload);
        break;
      case 'deleteInventoryLogs':
        result = deleteInventoryLogs(requestData.payload);
        break;
      default:
        result = { success: false, message: 'Invalid action' };
    }
  } catch (error) {
    result = { success: false, message: error.message };
  }

  return ContentService
    .createTextOutput(JSON.stringify(result))
    .setMimeType(ContentService.MimeType.JSON);
}


// --- 資料讀取 (GET) ---

function getItems() {
  const data = getDataWithCache(itemsSheet, 'items_data');
  const headers = data[0];
  const items = data.slice(1).map(row => {
    let item = {};
    headers.forEach((header, i) => {
      item[header] = row[i];
    });
    return item;
  });
  return { success: true, data: items };
}

function getInventoryLogs() {
  const data = getDataWithCache(inventoryLogSheet, 'inventory_logs_data');
  const logs = {};
  const logIdList = []; // 用來追蹤出現順序
  const LIMIT = 50; // 僅回傳最近的 50 筆紀錄

  // 從最後一行往前讀取，獲取最新的紀錄
  for (let i = data.length - 1; i > 0; i--) {
    const row = data[i];
    const logId = row[0].toString();
    
    if (!logs[logId]) {
      if (logIdList.length >= LIMIT) continue; // 超過限制則跳過新的 logId
      
      // 優化：只回傳選單需要的資訊，不回傳 items 明細以減輕傳輸量
      logs[logId] = { 
        logId: row[0], 
        timestamp: row[1], 
        category: row[2] 
      };
      logIdList.push(logId);
    }
  }

  // 將物件轉回陣列並按時間排序
  const sortedLogs = Object.values(logs).sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
  return { success: true, data: sortedLogs };
}

function getLogById(logId) {
    const data = getDataWithCache(inventoryLogSheet, 'inventory_logs_data');
    const logItems = [];
    let logInfo = {};
    for (let i = data.length - 1; i > 0; i--) {
        const row = data[i];
        if (row[0].toString() === logId) {
            if (!logInfo.logId) {
                logInfo = { logId: row[0], timestamp: row[1], category: row[2], items: [] };
            }
            logItems.unshift({ itemId: row[3], itemName: row[4], quantity: row[5] });
        } else {
            if(logInfo.logId) break;
        }
    }
    if (logInfo.logId) {
        logInfo.items = logItems;
        return { success: true, data: logInfo };
    } else {
        return { success: false, message: "Log not found" };
    }
}


function getDashboardData() {
  const cache = CacheService.getScriptCache();
  const cacheKey = 'dashboard_data_v6';
  const cached = cache.get(cacheKey);
  if (cached) {
    return JSON.parse(cached);
  }

  try {
    const bizSs = SpreadsheetApp.openById(BIZ_SHEET_ID);
    const sheet = bizSs.getSheets()[0];
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    const dateIndex = headers.indexOf('date');
    const staffIndex = headers.indexOf('關帳人員');
    const revenueIndex = headers.indexOf('營業額');
    const soupStockIndex = headers.indexOf('湯粉預估庫存');
    const records = data.slice(1).map(row => {
      const date = new Date(row[dateIndex]);
      if (isNaN(date.getTime())) return null;
      return {
        date: date,
        staff: row[staffIndex],
        revenue: Number(row[revenueIndex]) || 0,
        soupStock: Number(row[soupStockIndex]) || 0,
      };
    }).filter(r => r !== null)
      .sort((a,b) => b.date - a.date);
    if (records.length === 0) { return { success: true, data: { error: "No data found." } }; }
    
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const yesterday = new Date(today);
    yesterday.setDate(today.getDate() - 1);
    
    const latestRecord = records[0];
    const yesterdayRecord = records.find(r => r.date.toDateString() === yesterday.toDateString());
    const yesterdayRevenue = yesterdayRecord ? yesterdayRecord.revenue : 0;
    const latestSoupStock = latestRecord.soupStock;
    let currentMonthRevenue = 0, prevMonthRevenue = 0, prevPrevMonthRevenue = 0, prevMonthLastYearRevenue = 0;
    
    const currentMonth = today.getMonth();
    const currentYear = today.getFullYear();

    const prevMonthDate = new Date(today); prevMonthDate.setMonth(currentMonth - 1);
    const prevMonth = prevMonthDate.getMonth(); const prevMonthYear = prevMonthDate.getFullYear();
    const prevPrevMonthDate = new Date(today); prevPrevMonthDate.setMonth(currentMonth - 2);
    const prevPrevMonth = prevPrevMonthDate.getMonth(); const prevPrevMonthYear = prevPrevMonthDate.getFullYear();
    const prevMonthLastYearDate = new Date(today); prevMonthLastYearDate.setFullYear(currentYear - 1); prevMonthLastYearDate.setMonth(currentMonth - 1);
    const prevMonthLastYear = prevMonthLastYearDate.getMonth(); const prevMonthLastYear_Year = prevMonthLastYearDate.getFullYear();

    records.forEach(r => {
      const recordMonth = r.date.getMonth();
      const recordYear = r.date.getFullYear();
      if (recordYear === currentYear && recordMonth === currentMonth) {
        currentMonthRevenue += r.revenue;
      } else if (recordYear === prevMonthYear && recordMonth === prevMonth) {
        prevMonthRevenue += r.revenue;
      } else if (recordYear === prevPrevMonthYear && recordMonth === prevPrevMonth) {
        prevPrevMonthRevenue += r.revenue;
    
      } else if (recordYear === prevMonthLastYear_Year && recordMonth === prevMonthLastYear) {
        prevMonthLastYearRevenue += r.revenue;
      }
    });
    const prevMonthMoMTrend = prevPrevMonthRevenue > 0 ? ((prevMonthRevenue - prevPrevMonthRevenue) / prevPrevMonthRevenue) * 100 : 0;
    const prevMonthYoYTrend = prevMonthLastYearRevenue > 0 ? ((prevMonthRevenue - prevMonthLastYearRevenue) / prevMonthLastYearRevenue) * 100 : 0;

    const last30DaysRevenue = {};
    const endDate30Days = new Date(today);
    const startDate30Days = new Date(today);
    startDate30Days.setDate(today.getDate() - 30);
    
    records.filter(r => r.date >= startDate30Days && r.date < endDate30Days).forEach(r => {
      const dateString = Utilities.formatDate(r.date, "GMT+8", "M/d");
      last30DaysRevenue[dateString] = (last30DaysRevenue[dateString] || 0) + r.revenue;
    });

    for(let i = 1; i <= 30; i++){
      const d = new Date(today);
      d.setDate(today.getDate() - i);
      const dateString = Utilities.formatDate(d, "GMT+8", "M/d");
      if(!last30DaysRevenue[dateString]) {
        last30DaysRevenue[dateString] = 0;
      }
    }

    const monthlyRevenue = {}, monthlyStaffRevenue = {};
    const endDate = new Date(today.getFullYear(), today.getMonth(), 1); 
    const startDate = new Date(endDate.getFullYear() - 1, endDate.getMonth(), 1);
    records.filter(r => r.date >= startDate && r.date < endDate).forEach(r => { const mKey = Utilities.formatDate(r.date, "GMT+8", "yyyy/MM"); monthlyRevenue[mKey] = (monthlyRevenue[mKey] || 0) + r.revenue; if (!monthlyStaffRevenue[mKey]) monthlyStaffRevenue[mKey] = {}; monthlyStaffRevenue[mKey][r.staff] = (monthlyStaffRevenue[mKey][r.staff] || 0) + r.revenue; });
    const last12MonthsLabels = [];
    for(let i=0; i < 12; i++){ const d = new Date(startDate.getFullYear(), startDate.getMonth() + i, 1); const mKey = Utilities.formatDate(d, "GMT+8", "yyyy/MM"); last12MonthsLabels.push(mKey); }
    const last12MonthlyRevenueData = last12MonthsLabels.map(key => monthlyRevenue[key] || 0);
    const last12MonthlyStaffRevenueData = {};
    last12MonthsLabels.forEach(key => { last12MonthlyStaffRevenueData[key] = monthlyStaffRevenue[key] || {}; });
    
    const result = {
      success: true,
      data: {
        yesterdayRevenue,
        currentMonthRevenue,
        prevMonthRevenue,
        prevMonthMoMTrend,
        prevMonthYoYTrend,
        latestSoupStock,
        last30DaysRevenue: Object.entries(last30DaysRevenue).sort((a,b) => new Date(a[0]) - new Date(b[0])),
        last12Months: { labels: last12MonthsLabels, revenueData: last12MonthlyRevenueData, staffRevenueData: last12MonthlyStaffRevenueData },
        lastUpdated: new Date().toISOString()
      }
    };
    cache.put(cacheKey, JSON.stringify(result), 1800);
    return result;

  } catch(e) {
    return { success: false, message: '無法讀取營運概況工作表: ' + e.toString() };
  }
}

// --- MODIFICATION START: Final definitive fix for historical data ---
function getHistoricalDashboardData(startDateStr, endDateStr) {
    if (!startDateStr || !endDateStr) {
        return { success: false, message: 'Missing start or end date.' };
    }

    const cache = CacheService.getScriptCache();
    const cacheKey = `historical_data_v10_final_${startDateStr}_${endDateStr}`;
    const cached = cache.get(cacheKey);
    if (cached) {
        return JSON.parse(cached);
    }

    try {
        const startDate = new Date(startDateStr);
        const endDate = new Date(endDateStr);
        endDate.setHours(23, 59, 59, 999); 

        const bizSs = SpreadsheetApp.openById(BIZ_SHEET_ID);
        const sheet = bizSs.getSheets()[0];
        const data = sheet.getDataRange().getValues();
        const headers = data[0];
        const dateIndex = headers.indexOf('date');
        const staffIndex = headers.indexOf('關帳人員');
        const revenueIndex = headers.indexOf('營業額');

        const records = data.slice(1).map(row => {
            const date = new Date(row[dateIndex]);
            if (isNaN(date.getTime())) return null;
            return {
                date: date,
                staff: row[staffIndex] || '',
                revenue: Number(row[revenueIndex]) || 0,
            };
        }).filter(r => r !== null && r.date >= startDate && r.date <= endDate);

        if (records.length === 0) {
            return { success: true, data: { message: "指定區間內沒有資料。" } };
        }
        
        const highestRecord = records.reduce((max, current) => {
            return current.revenue > max.revenue ? current : max;
        }, { revenue: -1, staff: '', date: null });
        
        let totalRevenue = 0;
        const monthlyRevenue = {};
        const monthlyStaffRevenue = {};
        
        records.forEach(r => {
            totalRevenue += r.revenue;
            const mKey = Utilities.formatDate(r.date, "GMT+8", "yyyy/MM");
            monthlyRevenue[mKey] = (monthlyRevenue[mKey] || 0) + r.revenue;
            
            if (!monthlyStaffRevenue[mKey]) monthlyStaffRevenue[mKey] = {};
            if(r.staff) {
              monthlyStaffRevenue[mKey][r.staff] = (monthlyStaffRevenue[mKey][r.staff] || 0) + r.revenue;
            }
        });

        const avgDailyRevenue = records.length > 0 ? totalRevenue / records.length : 0;
        const highestMonth = Object.entries(monthlyRevenue).reduce((max, month) => month[1] > max[1] ? month : max, ["", 0]);
        const monthLabels = Object.keys(monthlyRevenue).sort();
        const monthlyRevenueData = monthLabels.map(key => monthlyRevenue[key] || 0);
        
        const result = {
            success: true,
            data: {
                totalRevenue,
                avgDailyRevenue,
                recordCount: records.length,
                highestDay: { 
                    date: highestRecord.date ? Utilities.formatDate(highestRecord.date, "GMT+8", "yyyy-MM-dd") : 'N/A',
                    revenue: highestRecord.revenue,
                    staff: highestRecord.staff || ''
                },
                highestMonth: {
                    month: highestMonth[0],
                    revenue: highestMonth[1]
                },
                monthlyData: {
                    labels: monthLabels,
                    revenueData: monthlyRevenueData,
                    staffRevenueData: monthlyStaffRevenue
                },
            }
        };

        cache.put(cacheKey, JSON.stringify(result), CACHE_EXPIRATION_LONG);
        return result;

    } catch (e) {
        return { success: false, message: '讀取歷史資料時發生錯誤: ' + e.toString() };
    }
}
// --- MODIFICATION END ---

// --- 資料寫入 (POST) ---
function verifyAccessCode(code) {
  const correctCode = configSheet.getRange('B2').getValue();
  if (code === correctCode.toString()) {
    return { success: true };
  } else {
    return { success: false, message: 'Incorrect access code' };
  }
}

function updateSettings(payload) {
    if (payload.newAccessCode) {
        const oldCode = configSheet.getRange('B2').getValue();
        if (payload.oldAccessCode === oldCode.toString()) {
            configSheet.getRange('B2').setValue(payload.newAccessCode);
        } else {
            throw new Error('舊存取碼錯誤');
        }
    }
    const itemsData = payload.items;
    if (itemsData) {
        const headers = itemsSheet.getRange(1, 1, 1, itemsSheet.getLastColumn()).getValues()[0];
        if(itemsSheet.getLastRow() > 1) {
          itemsSheet.getRange(2, 1, itemsSheet.getLastRow() - 1, itemsSheet.getLastColumn()).clearContent();
        }
        if (itemsData.length > 0) {
          const newValues = itemsData.map(item => headers.map(header => item[header] || ""));
          itemsSheet.getRange(2, 1, newValues.length, newValues[0].length).setValues(newValues);
        }
        invalidateCache('items_data');
    }
    return { success: true, message: '設定已更新' };
}

function saveInventory(payload) {
  const timestamp = new Date();
  const logId = Utilities.formatDate(timestamp, "GMT+8", "yyyyMMddHHmmss");
  const records = payload.items.map(item => {
    return [logId, timestamp, payload.category, item.itemId, item.itemName, item.quantity];
  });
  inventoryLogSheet.getRange(inventoryLogSheet.getLastRow() + 1, 1, records.length, records[0].length).setValues(records);
  invalidateCache('inventory_logs_data');
  return { success: true, message: '盤點紀錄已儲存', logId: logId };
}

function deleteInventoryLogs(payload) {
  const logIdsToDelete = payload.logIds;
  const accessCode = payload.accessCode;
  const correctCode = configSheet.getRange('B2').getValue().toString();
  if (accessCode !== correctCode) {
    return { success: false, message: '存取碼錯誤' };
  }
  if (!logIdsToDelete || logIdsToDelete.length === 0) {
    return { success: false, message: '沒有指定要刪除的紀錄' };
  }
  const data = inventoryLogSheet.getDataRange().getValues();
  const rowsToDelete = [];
  const logIdSet = new Set(logIdsToDelete.map(String));
  data.forEach((row, index) => {
    if (logIdSet.has(row[0].toString())) {
      rowsToDelete.push(index + 1);
    }
  });
  if (rowsToDelete.length === 0) {
    return { success: false, message: '找不到對應的盤點紀錄' };
  }
  for (let i = rowsToDelete.length - 1; i >= 0; i--) {
    inventoryLogSheet.deleteRow(rowsToDelete[i]);
  }
  invalidateCache('inventory_logs_data');
  return { success: true, message: `${logIdsToDelete.length} 筆盤點紀錄已成功刪除` };
}